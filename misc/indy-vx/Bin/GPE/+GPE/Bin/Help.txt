o Получение управления при понижении SFN из калбэка.

; Routine() -> ... -> Notify().

Initialize:
Graph = CreateGraph(@Routine, NL = 1)
-
Notify:
    Frame:PSTACK_FRAME
    Frame = rEbp
    Do
       if CheckIpBelongToGraph(Graph, Frame.Ip)
       Tls = AllocateTls()
       Tls.Ip = Frame.Ip
       Frame.Ip = @2ndDispatch()
       End
       endif
       Frame = Frame.Next
    Loop END_OF_CHAIN

2ndDispatch:
    Payload()
    Ip = Tls.Ip
    FreeTls(Tls)
    Jmp Ip
;			~

o Получение управления при понижении SFN из калбэка.
o Процедура не известна, известен адрес инструкции принадлежащий ей.

; Routine() -> ... -> Notify().

Initialize:
   CreateGraph(@Routine, @ParseCallback)
-
ParseCallback(CurrentEntry:PGRAPH_ENTRY, CallList:PCALL_ENTRY):
   if CurrentEntry.Ip = TargetIp
      Graph = CallList[0].BranchLink
-
Notify:
    Frame:PSTACK_FRAME
    Frame = rEbp
    Do
       if CheckIpBelongToGraph(Graph, Frame.Ip)
       Tls = AllocateTls()
       Tls.Ip = Frame.Ip
       Frame.Ip = @2ndDispatch()
       End
       endif
       Frame = Frame.Next
    Loop END_OF_CHAIN

2ndDispatch:
    Payload()
    Ip = Tls.Ip
    FreeTls(Tls)
    Jmp Ip

;			~

o Тоже что и пред., но используя ядрес возврата.

Initialize:
   CreateGraph(@Routine, @ParseCallback)
-
ParseCallback(CurrentEntry:PGRAPH_ENTRY, CallList:PCALL_ENTRY):
   if CurrentEntry.Ip = TargetIp
      Ip = CallList[0].Address + LDE(CallList[0].Address)
      ; Ip = CallList[0].Flink.Address
-
Notify:
    Frame:PSTACK_FRAME
    Frame = rEbp
    Do
       if Frame.Ip = Ip
       Tls = AllocateTls()
       Tls.Ip = Frame.Ip
       Frame.Ip = @2ndDispatch()
       End
       endif
       Frame = Frame.Next
    Loop END_OF_CHAIN

2ndDispatch:
    Payload()
    Ip = Tls.Ip
    FreeTls(Tls)
    Jmp Ip

;			~
o Прерывание трассировки графа требует очистку флагов.

    Do
    ENTRY.ACCESSED_MASK_FLAG -> 0
    Loop EOL
;			~

o Трассировка линейного блока.
    if ENTRY.SEPARATE_MACRO_FLAG
       Size = 0
       Do
          Callback()
          Size = Size + LDE(ENTRY.Ip + Size)
       Loop Size < ENTRY.Size
    else
       Callback()
    endif
;			~

o Вычисление размера процедуры.

	Size = 0
	Do
	if ENTRY.Type = TYPE_LINE
	   Size = Size + ENTRY.Size
	else
	   Size = Size + LDE(ENTRY.Ip)
	endif
	Loop END_OF_CHAIN
;			~